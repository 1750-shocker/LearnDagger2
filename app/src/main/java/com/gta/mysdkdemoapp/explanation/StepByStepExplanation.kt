package com.gta.mysdkdemoapp.explanation

import com.gta.mysdkdemoapp.dagger.annotations.*
import com.gta.mysdkdemoapp.dagger.SimpleDagger

/**
 * 一步一步解释：为什么Dagger要这样写？
 * 每一行代码都有详细注释说明原因
 */

// ==================== 第一步：传统方式的痛苦 ====================

/**
 * 传统方式：你要自己创建所有依赖
 * 问题：麻烦、容易出错、难测试、难维护
 */
class 传统方式的痛苦 {
    
    fun 获取用户数据_传统方式(): String {
        // 🤮 看看这有多痛苦！
        // 我只想要个用户数据，但是...
        
        // 1. 我要知道网络配置怎么创建
        val 网络配置 = 网络配置类("https://api.com", 30000)
        
        // 2. 我要知道网络服务需要配置
        val 网络服务 = 网络服务类(网络配置)
        
        // 3. 我要知道数据库怎么创建
        val 数据库 = 数据库类("user.db")
        
        // 4. 我要知道数据库服务需要数据库
        val 数据库服务 = 数据库服务类(数据库)
        
        // 5. 最后才能创建我真正想要的
        val 用户仓库 = 用户仓库类(网络服务, 数据库服务)
        
        // 6. 终于可以用了！
        return 用户仓库.获取用户数据()
        
        // 😭 问题：
        // - 我要记住所有这些依赖关系
        // - 如果网络服务类的构造函数改了，我这里也要改
        // - 测试的时候，我要手动创建所有假对象
        // - 如果有10个地方用到用户仓库，我要写10遍这些代码
    }
}

// ==================== 第二步：用注解标记需求 ====================

/**
 * 为什么要写@Inject？
 * 答：告诉系统"这里需要依赖注入，你帮我准备参数"
 */
class 用户仓库类 @Inject constructor(  // ← 这个@Inject就是在说："系统，帮我准备参数！"
    private val 网络服务: 网络服务类,      // ← "我需要网络服务，你给我找一个"
    private val 数据库服务: 数据库服务类    // ← "我需要数据库服务，你给我找一个"
) {
    fun 获取用户数据(): String {
        // 我不管网络服务和数据库服务从哪来
        // 反正有人会给我准备好，我只管用！
        val 网络数据 = 网络服务.获取数据()
        数据库服务.保存数据(网络数据)
        return "用户数据：$网络数据"
    }
}

/**
 * 为什么网络服务类也要@Inject？
 * 答：因为它也需要依赖（网络配置），所以也要标记
 */
class 网络服务类 @Inject constructor(
    private val 配置: 网络配置类  // ← "我需要配置，你给我找一个"
) {
    fun 获取数据(): String = "从${配置.baseUrl}获取的数据"
}

/**
 * 为什么数据库服务类也要@Inject？
 * 答：虽然它的依赖简单，但统一用@Inject，系统就能自动处理
 */
class 数据库服务类 @Inject constructor(
    private val 数据库: 数据库类  // ← "我需要数据库，你给我找一个"
) {
    fun 保存数据(data: String) = println("保存到${数据库.name}: $data")
}

// ==================== 第三步：复杂依赖用模块处理 ====================

/**
 * 为什么要写@Module？
 * 答：有些对象创建很复杂，需要专门的"工厂"来处理
 */
@Module  // ← "我是专业工厂，专门制造复杂的东西"
class 配置模块 {
    
    /**
     * 为什么要写@Provides？
     * 答：告诉系统"这个方法能生产某种对象"
     */
    @Provides  // ← "这个方法能生产网络配置"
    fun 提供网络配置(): 网络配置类 {
        // 复杂的创建逻辑写在这里
        // 比如：根据环境选择不同的配置
        return if (是测试环境()) {
            网络配置类("http://test.api.com", 5000)
        } else {
            网络配置类("https://prod.api.com", 30000)
        }
    }
    
    @Provides  // ← "这个方法能生产数据库"
    fun 提供数据库(): 数据库类 {
        // 数据库的创建也可能很复杂
        return 数据库类("production.db")
    }
    
    private fun 是测试环境(): Boolean = false // 简化的判断
}

// ==================== 第四步：组件协调一切 ====================

/**
 * 为什么要写@Component？
 * 答：需要一个"总经理"来协调所有工厂和依赖关系
 */
@Component(modules = [配置模块::class])  // ← "我知道找配置模块要复杂的东西"
interface 应用组件 {
    
    /**
     * 为什么要写这个方法？
     * 答：告诉系统"我能提供用户仓库类的实例"
     */
    fun 获取用户仓库(): 用户仓库类  // ← "你要用户仓库？我给你造一个！"
    
    /**
     * 为什么要写inject方法？
     * 答：有时候对象已经存在了，只需要往里面注入依赖
     */
    fun 注入到主页面(activity: 主页面类)  // ← "你已经有对象了？我帮你注入依赖！"
}

// ==================== 第五步：简单的数据类 ====================

/**
 * 为什么这些类不需要@Inject？
 * 答：因为它们是简单的数据类，不需要复杂的依赖注入
 */
data class 网络配置类(val baseUrl: String, val timeout: Int)
data class 数据库类(val name: String)

// ==================== 第六步：使用演示 ====================

class 主页面类 {
    
    fun 依赖注入方式_简单多了(): String {
        // 🎉 看看现在多简单！
        
        // 1. 找到总经理（组件）
        val 总经理 = SimpleDagger.create<应用组件>()
        
        // 2. 要什么直接说
        val 用户仓库 = 总经理.获取用户仓库()
        
        // 3. 直接用，不用管依赖从哪来
        return 用户仓库.获取用户数据()
        
        // 😍 好处：
        // - 我只需要知道我要什么，不需要知道怎么创建
        // - 所有依赖关系都由系统自动处理
        // - 测试时可以轻松替换组件
        // - 代码简洁，易维护
    }
}

// ==================== 第七步：演示类 ====================

class 逐步解释演示 {
    
    fun 运行演示(): String {
        return try {
            val 主页面 = 主页面类()
            val 结果 = 主页面.依赖注入方式_简单多了()
            
            """
                🎯 逐步解释演示完成！
                
                📝 每个注解的作用：
                
                @Inject     → "我需要依赖，系统帮我准备参数"
                @Module     → "我是专业工厂，制造复杂对象"  
                @Provides   → "这个方法能生产某种对象"
                @Component  → "我是总经理，协调一切"
                
                🔄 工作流程：
                1. 你说："我要用户仓库"
                2. 系统看到用户仓库有@Inject，知道要帮你创建
                3. 系统发现用户仓库需要网络服务和数据库服务
                4. 系统看到网络服务需要网络配置
                5. 系统去配置模块找到提供网络配置的方法
                6. 系统按顺序创建：配置→服务→仓库
                7. 系统把创建好的仓库给你
                
                💡 核心思想：
                你只管声明需求，系统自动满足需求！
                
                📊 实际结果：$结果
            """.trimIndent()
            
        } catch (e: Exception) {
            "演示出错：${e.message}"
        }
    }
}